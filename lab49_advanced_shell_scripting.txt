RHCE RH254 HANDS-ON LAB: ADVANCED SHELL SCRIPTING
===============================================

LAB OBJECTIVE:
Master advanced shell scripting techniques including complex functions, error handling, signal processing, advanced parameter handling, and enterprise-grade script development

PREREQUISITES:
- RHEL 8/9 system with root access
- Understanding of basic shell scripting
- Knowledge of Linux system administration
- Familiarity with command-line tools

LAB SCENARIO:
Develop enterprise-grade shell scripts with advanced features including robust error handling, logging, configuration management, and automated system administration tasks.

EQUIPMENT NEEDED:
- RHEL system (192.168.1.20)
- Text editor (vim/nano)
- Various system utilities for script testing

LAB TASKS:

PART A: ADVANCED SCRIPT STRUCTURE AND FUNCTIONS
------------------------------------------------

1. Create advanced script template:
   # mkdir -p /opt/scripts/{templates,functions,configs,logs}
   # vim /opt/scripts/templates/advanced-script-template.sh
   
   #!/bin/bash
   #
   # Advanced Shell Script Template
   # Author: System Administrator
   # Version: 1.0
   # Description: Enterprise-grade script template with advanced features
   #
   
   # Script metadata
   readonly SCRIPT_NAME="$(basename "$0")"
   readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
   readonly SCRIPT_VERSION="1.0"
   readonly SCRIPT_AUTHOR="System Administrator"
   
   # Configuration
   readonly CONFIG_FILE="${SCRIPT_DIR}/../configs/${SCRIPT_NAME%.sh}.conf"
   readonly LOG_FILE="/var/log/${SCRIPT_NAME%.sh}.log"
   readonly PID_FILE="/var/run/${SCRIPT_NAME%.sh}.pid"
   
   # Global variables
   DEBUG=false
   VERBOSE=false
   DRY_RUN=false
   FORCE=false
   
   # Color codes for output
   readonly RED='\033[0;31m'
   readonly GREEN='\033[0;32m'
   readonly YELLOW='\033[1;33m'
   readonly BLUE='\033[0;34m'
   readonly NC='\033[0m' # No Color
   
   # Logging functions
   log_message() {
       local level="$1"
       local message="$2"
       local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
       echo "[$timestamp] [$level] $message" >> "$LOG_FILE"
       
       case "$level" in
           "ERROR")
               echo -e "${RED}[ERROR]${NC} $message" >&2
               ;;
           "WARN")
               echo -e "${YELLOW}[WARN]${NC} $message" >&2
               ;;
           "INFO")
               [ "$VERBOSE" = true ] && echo -e "${GREEN}[INFO]${NC} $message"
               ;;
           "DEBUG")
               [ "$DEBUG" = true ] && echo -e "${BLUE}[DEBUG]${NC} $message"
               ;;
       esac
   }
   
   log_error() { log_message "ERROR" "$1"; }
   log_warn() { log_message "WARN" "$1"; }
   log_info() { log_message "INFO" "$1"; }
   log_debug() { log_message "DEBUG" "$1"; }
   
   # Error handling
   error_exit() {
       log_error "$1"
       cleanup
       exit "${2:-1}"
   }
   
   # Signal handling
   cleanup() {
       log_info "Cleaning up..."
       [ -f "$PID_FILE" ] && rm -f "$PID_FILE"
       # Add cleanup tasks here
   }
   
   signal_handler() {
       local signal="$1"
       log_warn "Received signal: $signal"
       cleanup
       exit 130
   }
   
   # Set up signal traps
   trap 'signal_handler INT' INT
   trap 'signal_handler TERM' TERM
   trap 'cleanup' EXIT
   
   # Usage function
   usage() {
       cat << EOF
   Usage: $SCRIPT_NAME [OPTIONS] [ARGUMENTS]
   
   DESCRIPTION:
       Advanced shell script template with enterprise features
   
   OPTIONS:
       -h, --help          Show this help message
       -v, --verbose       Enable verbose output
       -d, --debug         Enable debug output
       -n, --dry-run       Show what would be done without executing
       -f, --force         Force execution without prompts
       -c, --config FILE   Use custom configuration file
       -V, --version       Show version information
   
   EXAMPLES:
       $SCRIPT_NAME --verbose
       $SCRIPT_NAME --config /path/to/config.conf
       $SCRIPT_NAME --dry-run --debug
   
   EOF
   }
   
   # Version information
   version_info() {
       cat << EOF
   $SCRIPT_NAME version $SCRIPT_VERSION
   Author: $SCRIPT_AUTHOR
   EOF
   }
   
   # Configuration loading
   load_config() {
       local config_file="${1:-$CONFIG_FILE}"
       
       if [ -f "$config_file" ]; then
           log_debug "Loading configuration from: $config_file"
           source "$config_file"
       else
           log_warn "Configuration file not found: $config_file"
       fi
   }
   
   # Parameter validation
   validate_parameters() {
       # Add parameter validation logic here
       return 0
   }
   
   # Main function
   main() {
       log_info "Starting $SCRIPT_NAME v$SCRIPT_VERSION"
       
       # Create PID file
       echo $$ > "$PID_FILE"
       
       # Load configuration
       load_config
       
       # Validate parameters
       validate_parameters || error_exit "Parameter validation failed"
       
       # Main script logic goes here
       log_info "Main script execution completed"
   }
   
   # Parameter parsing
   while [[ $# -gt 0 ]]; do
       case $1 in
           -h|--help)
               usage
               exit 0
               ;;
           -v|--verbose)
               VERBOSE=true
               shift
               ;;
           -d|--debug)
               DEBUG=true
               VERBOSE=true
               shift
               ;;
           -n|--dry-run)
               DRY_RUN=true
               shift
               ;;
           -f|--force)
               FORCE=true
               shift
               ;;
           -c|--config)
               CONFIG_FILE="$2"
               shift 2
               ;;
           -V|--version)
               version_info
               exit 0
               ;;
           -*)
               error_exit "Unknown option: $1"
               ;;
           *)
               # Positional arguments
               break
               ;;
       esac
   done
   
   # Execute main function
   main "$@"

2. Create advanced function library:
   # vim /opt/scripts/functions/advanced-functions.sh
   
   #!/bin/bash
   #
   # Advanced Shell Functions Library
   # Collection of reusable functions for enterprise scripts
   #
   
   # Check if running as root
   require_root() {
       if [[ $EUID -ne 0 ]]; then
           echo "This script must be run as root" >&2
           exit 1
       fi
   }
   
   # Check if command exists
   command_exists() {
       command -v "$1" >/dev/null 2>&1
   }
   
   # Prompt for confirmation
   confirm() {
       local prompt="${1:-Are you sure?}"
       local default="${2:-n}"
       
       if [ "$FORCE" = true ]; then
           return 0
       fi
       
       while true; do
           read -p "$prompt [y/N]: " -r response
           response=${response:-$default}
           
           case $response in
               [Yy]|[Yy][Ee][Ss])
                   return 0
                   ;;
               [Nn]|[Nn][Oo])
                   return 1
                   ;;
               *)
                   echo "Please answer yes or no."
                   ;;
           esac
       done
   }
   
   # Execute command with logging
   execute_command() {
       local cmd="$1"
       local description="${2:-Executing command}"
       
       log_debug "$description: $cmd"
       
       if [ "$DRY_RUN" = true ]; then
           log_info "[DRY RUN] Would execute: $cmd"
           return 0
       fi
       
       if eval "$cmd"; then
           log_info "$description: SUCCESS"
           return 0
       else
           local exit_code=$?
           log_error "$description: FAILED (exit code: $exit_code)"
           return $exit_code
       fi
   }
   
   # Retry function with exponential backoff
   retry_with_backoff() {
       local max_attempts="$1"
       local delay="$2"
       local command="$3"
       local attempt=1
       
       while [ $attempt -le $max_attempts ]; do
           log_debug "Attempt $attempt of $max_attempts: $command"
           
           if eval "$command"; then
               log_info "Command succeeded on attempt $attempt"
               return 0
           fi
           
           if [ $attempt -eq $max_attempts ]; then
               log_error "Command failed after $max_attempts attempts"
               return 1
           fi
           
           log_warn "Attempt $attempt failed, retrying in ${delay}s..."
           sleep $delay
           delay=$((delay * 2))  # Exponential backoff
           attempt=$((attempt + 1))
       done
   }
   
   # Progress bar function
   progress_bar() {
       local current="$1"
       local total="$2"
       local width="${3:-50}"
       local prefix="${4:-Progress}"
       
       local percentage=$((current * 100 / total))
       local completed=$((current * width / total))
       local remaining=$((width - completed))
       
       printf "\r%s: [" "$prefix"
       printf "%*s" $completed | tr ' ' '='
       printf "%*s" $remaining | tr ' ' '-'
       printf "] %d%% (%d/%d)" $percentage $current $total
       
       if [ $current -eq $total ]; then
           echo
       fi
   }
   
   # File backup function
   backup_file() {
       local file="$1"
       local backup_dir="${2:-/tmp/backups}"
       
       if [ ! -f "$file" ]; then
           log_error "File not found: $file"
           return 1
       fi
       
       mkdir -p "$backup_dir"
       local backup_file="$backup_dir/$(basename "$file").$(date +%Y%m%d_%H%M%S).bak"
       
       if cp "$file" "$backup_file"; then
           log_info "File backed up: $file -> $backup_file"
           echo "$backup_file"
           return 0
       else
           log_error "Failed to backup file: $file"
           return 1
       fi
   }
   
   # Network connectivity check
   check_connectivity() {
       local host="${1:-8.8.8.8}"
       local timeout="${2:-5}"
       
       if ping -c 1 -W $timeout "$host" >/dev/null 2>&1; then
           log_debug "Network connectivity to $host: OK"
           return 0
       else
           log_warn "Network connectivity to $host: FAILED"
           return 1
       fi
   }
   
   # Service management functions
   ensure_service_running() {
       local service="$1"
       
       if systemctl is-active "$service" >/dev/null 2>&1; then
           log_debug "Service $service is already running"
           return 0
       fi
       
       log_info "Starting service: $service"
       if systemctl start "$service"; then
           log_info "Service $service started successfully"
           return 0
       else
           log_error "Failed to start service: $service"
           return 1
       fi
   }
   
   # Disk space check
   check_disk_space() {
       local path="${1:-/}"
       local threshold="${2:-90}"
       
       local usage=$(df "$path" | tail -1 | awk '{print $5}' | sed 's/%//')
       
       if [ "$usage" -gt "$threshold" ]; then
           log_warn "Disk usage for $path is ${usage}% (threshold: ${threshold}%)"
           return 1
       else
           log_debug "Disk usage for $path is ${usage}% (OK)"
           return 0
       fi
   }
   
   # Array manipulation functions
   array_contains() {
       local element="$1"
       shift
       local array=("$@")
       
       for item in "${array[@]}"; do
           if [ "$item" = "$element" ]; then
               return 0
           fi
       done
       return 1
   }
   
   # String manipulation functions
   trim_whitespace() {
       local string="$1"
       echo "$string" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
   }
   
   # Configuration file parsing
   parse_config_value() {
       local config_file="$1"
       local key="$2"
       local default_value="${3:-}"
       
       if [ -f "$config_file" ]; then
           local value=$(grep "^$key=" "$config_file" | cut -d'=' -f2- | tr -d '"' | tr -d "'")
           echo "${value:-$default_value}"
       else
           echo "$default_value"
       fi
   }

PART B: ERROR HANDLING AND DEBUGGING
-------------------------------------

1. Create error handling framework:
   # vim /opt/scripts/functions/error-handling.sh
   
   #!/bin/bash
   #
   # Advanced Error Handling Framework
   #
   
   # Error codes
   readonly E_SUCCESS=0
   readonly E_GENERAL=1
   readonly E_MISUSE=2
   readonly E_NOEXEC=126
   readonly E_NOTFOUND=127
   readonly E_INVALID_ARG=128
   readonly E_FATAL=130
   
   # Error tracking
   ERROR_COUNT=0
   WARNING_COUNT=0
   
   # Stack trace function
   print_stack_trace() {
       local frame=0
       echo "Stack trace:" >&2
       
       while caller $frame >&2; do
           ((frame++))
       done
   }
   
   # Enhanced error exit
   die() {
       local exit_code="${1:-$E_GENERAL}"
       local message="${2:-An error occurred}"
       
       log_error "$message"
       
       if [ "$DEBUG" = true ]; then
           print_stack_trace
       fi
       
       cleanup
       exit "$exit_code"
   }
   
   # Error accumulator
   add_error() {
       local message="$1"
       ERROR_COUNT=$((ERROR_COUNT + 1))
       log_error "Error #$ERROR_COUNT: $message"
   }
   
   add_warning() {
       local message="$1"
       WARNING_COUNT=$((WARNING_COUNT + 1))
       log_warn "Warning #$WARNING_COUNT: $message"
   }
   
   # Check for accumulated errors
   check_errors() {
       if [ $ERROR_COUNT -gt 0 ]; then
           die $E_GENERAL "Script completed with $ERROR_COUNT error(s) and $WARNING_COUNT warning(s)"
       elif [ $WARNING_COUNT -gt 0 ]; then
           log_warn "Script completed with $WARNING_COUNT warning(s)"
       fi
   }
   
   # Assertion function
   assert() {
       local condition="$1"
       local message="${2:-Assertion failed}"
       
       if ! eval "$condition"; then
           die $E_GENERAL "ASSERTION FAILED: $message"
       fi
   }
   
   # Try-catch simulation
   try() {
       local command="$1"
       local error_handler="${2:-}"
       
       if ! eval "$command"; then
           local exit_code=$?
           if [ -n "$error_handler" ]; then
               eval "$error_handler $exit_code"
           else
               add_error "Command failed: $command (exit code: $exit_code)"
           fi
           return $exit_code
       fi
       return 0
   }

2. Create debugging utilities:
   # vim /opt/scripts/functions/debug-utils.sh
   
   #!/bin/bash
   #
   # Debugging Utilities
   #
   
   # Debug trace
   debug_trace() {
       if [ "$DEBUG" = true ]; then
           echo "DEBUG: ${BASH_SOURCE[1]}:${BASH_LINENO[0]} ${FUNCNAME[1]}()" >&2
       fi
   }
   
   # Variable dumper
   dump_vars() {
       local prefix="${1:-}"
       
       if [ "$DEBUG" = true ]; then
           echo "=== Variable Dump ===" >&2
           if [ -n "$prefix" ]; then
               set | grep "^$prefix" >&2
           else
               set >&2
           fi
           echo "===================" >&2
       fi
   }
   
   # Function call tracer
   trace_calls() {
       if [ "$DEBUG" = true ]; then
           set -x
       fi
   }
   
   stop_trace() {
       set +x
   }
   
   # Performance timing
   start_timer() {
       TIMER_START=$(date +%s.%N)
   }
   
   end_timer() {
       local label="${1:-Operation}"
       local end_time=$(date +%s.%N)
       local duration=$(echo "$end_time - $TIMER_START" | bc)
       log_debug "$label took ${duration}s"
   }
   
   # Memory usage tracker
   check_memory_usage() {
       local process_name="${1:-$$}"
       local memory_kb=$(ps -o rss= -p "$process_name" 2>/dev/null)
       
       if [ -n "$memory_kb" ]; then
           local memory_mb=$((memory_kb / 1024))
           log_debug "Memory usage: ${memory_mb}MB"
       fi
   }
PART C: ADVANCED PARAMETER HANDLING
------------------------------------

1. Create parameter processing framework:
   # vim /opt/scripts/functions/parameter-handling.sh
   
   #!/bin/bash
   #
   # Advanced Parameter Handling Framework
   #
   
   # Parameter validation functions
   validate_integer() {
       local value="$1"
       local min="${2:-}"
       local max="${3:-}"
       
       if ! [[ "$value" =~ ^[0-9]+$ ]]; then
           return 1
       fi
       
       if [ -n "$min" ] && [ "$value" -lt "$min" ]; then
           return 1
       fi
       
       if [ -n "$max" ] && [ "$value" -gt "$max" ]; then
           return 1
       fi
       
       return 0
   }
   
   validate_email() {
       local email="$1"
       local regex="^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
       
       if [[ "$email" =~ $regex ]]; then
           return 0
       else
           return 1
       fi
   }
   
   validate_ip_address() {
       local ip="$1"
       local regex="^([0-9]{1,3}\.){3}[0-9]{1,3}$"
       
       if [[ "$ip" =~ $regex ]]; then
           # Check each octet
           IFS='.' read -ra octets <<< "$ip"
           for octet in "${octets[@]}"; do
               if [ "$octet" -gt 255 ]; then
                   return 1
               fi
           done
           return 0
       else
           return 1
       fi
   }
   
   validate_file_path() {
       local path="$1"
       local must_exist="${2:-false}"
       
       if [ "$must_exist" = true ] && [ ! -e "$path" ]; then
           return 1
       fi
       
       # Check if path is valid (basic check)
       if [[ "$path" =~ ^[a-zA-Z0-9/_.-]+$ ]]; then
           return 0
       else
           return 1
       fi
   }
   
   # Advanced option parsing
   parse_long_options() {
       local args=("$@")
       local parsed_args=()
       
       for arg in "${args[@]}"; do
           case "$arg" in
               --*=*)
                   # Split --option=value
                   local option="${arg%%=*}"
                   local value="${arg#*=}"
                   parsed_args+=("$option" "$value")
                   ;;
               --*)
                   parsed_args+=("$arg")
                   ;;
               *)
                   parsed_args+=("$arg")
                   ;;
           esac
       done
       
       echo "${parsed_args[@]}"
   }
   
   # Configuration file parameter override
   override_with_config() {
       local config_file="$1"
       shift
       local variables=("$@")
       
       if [ -f "$config_file" ]; then
           for var in "${variables[@]}"; do
               local value=$(parse_config_value "$config_file" "$var")
               if [ -n "$value" ]; then
                   declare -g "$var"="$value"
                   log_debug "Override from config: $var=$value"
               fi
           done
       fi
   }
   
   # Environment variable parameter override
   override_with_env() {
       local prefix="$1"
       shift
       local variables=("$@")
       
       for var in "${variables[@]}"; do
           local env_var="${prefix}_${var^^}"
           if [ -n "${!env_var:-}" ]; then
               declare -g "$var"="${!env_var}"
               log_debug "Override from environment: $var=${!env_var}"
           fi
       done
   }

2. Create configuration management system:
   # vim /opt/scripts/functions/config-management.sh
   
   #!/bin/bash
   #
   # Configuration Management System
   #
   
   # Configuration file template generator
   generate_config_template() {
       local config_file="$1"
       local script_name="${2:-$(basename "$0" .sh)}"
       
       cat > "$config_file" << EOF
   # Configuration file for $script_name
   # Generated on $(date)
   
   # General settings
   DEBUG=false
   VERBOSE=false
   LOG_LEVEL=INFO
   
   # Paths
   LOG_DIR=/var/log
   TEMP_DIR=/tmp
   BACKUP_DIR=/backup
   
   # Network settings
   TIMEOUT=30
   RETRY_COUNT=3
   
   # Email notifications
   ENABLE_EMAIL=false
   ADMIN_EMAIL=admin@example.com
   SMTP_SERVER=localhost
   
   # Custom settings (add your own below)
   # CUSTOM_SETTING=value
   EOF
       
       log_info "Configuration template created: $config_file"
   }
   
   # Configuration validation
   validate_config() {
       local config_file="$1"
       local required_vars=("$@")
       shift
       
       if [ ! -f "$config_file" ]; then
           log_error "Configuration file not found: $config_file"
           return 1
       fi
       
       local missing_vars=()
       
       for var in "${required_vars[@]}"; do
           local value=$(parse_config_value "$config_file" "$var")
           if [ -z "$value" ]; then
               missing_vars+=("$var")
           fi
       done
       
       if [ ${#missing_vars[@]} -gt 0 ]; then
           log_error "Missing required configuration variables: ${missing_vars[*]}"
           return 1
       fi
       
       return 0
   }
   
   # Dynamic configuration reloading
   reload_config() {
       local config_file="$1"
       
       if [ -f "$config_file" ]; then
           log_info "Reloading configuration from: $config_file"
           source "$config_file"
           return 0
       else
           log_error "Cannot reload config, file not found: $config_file"
           return 1
       fi
   }

PART D: SYSTEM ADMINISTRATION SCRIPTS
--------------------------------------

1. Create system monitoring script:
   # vim /opt/scripts/system-monitor.sh
   
   #!/bin/bash
   #
   # Advanced System Monitoring Script
   #
   
   # Source function libraries
   source /opt/scripts/functions/advanced-functions.sh
   source /opt/scripts/functions/error-handling.sh
   source /opt/scripts/functions/debug-utils.sh
   
   # Script configuration
   readonly SCRIPT_NAME="system-monitor"
   readonly CONFIG_FILE="/opt/scripts/configs/system-monitor.conf"
   readonly LOG_FILE="/var/log/system-monitor.log"
   
   # Default thresholds
   CPU_THRESHOLD=80
   MEMORY_THRESHOLD=85
   DISK_THRESHOLD=90
   LOAD_THRESHOLD=2.0
   
   # Monitoring functions
   check_cpu_usage() {
       local cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1 | cut -d'.' -f1)
       
       log_debug "CPU usage: ${cpu_usage}%"
       
       if [ "$cpu_usage" -gt "$CPU_THRESHOLD" ]; then
           add_warning "High CPU usage: ${cpu_usage}% (threshold: ${CPU_THRESHOLD}%)"
           
           # Get top CPU processes
           local top_processes=$(ps aux --sort=-%cpu | head -6 | tail -5)
           log_info "Top CPU processes:\n$top_processes"
       fi
       
       echo "$cpu_usage"
   }
   
   check_memory_usage() {
       local memory_usage=$(free | grep Mem | awk '{printf("%.0f", $3/$2 * 100.0)}')
       
       log_debug "Memory usage: ${memory_usage}%"
       
       if [ "$memory_usage" -gt "$MEMORY_THRESHOLD" ]; then
           add_warning "High memory usage: ${memory_usage}% (threshold: ${MEMORY_THRESHOLD}%)"
           
           # Get top memory processes
           local top_processes=$(ps aux --sort=-%mem | head -6 | tail -5)
           log_info "Top memory processes:\n$top_processes"
       fi
       
       echo "$memory_usage"
   }
   
   check_disk_usage() {
       local alerts=()
       
       df -h | grep -E '^/dev/' | while read line; do
           local usage=$(echo $line | awk '{print $5}' | cut -d'%' -f1)
           local filesystem=$(echo $line | awk '{print $6}')
           
           log_debug "Disk usage $filesystem: ${usage}%"
           
           if [ "$usage" -gt "$DISK_THRESHOLD" ]; then
               add_warning "High disk usage: $filesystem ${usage}% (threshold: ${DISK_THRESHOLD}%)"
               
               # Find largest files
               local large_files=$(find "$filesystem" -type f -size +100M 2>/dev/null | head -5)
               if [ -n "$large_files" ]; then
                   log_info "Large files in $filesystem:\n$large_files"
               fi
           fi
       done
   }
   
   check_load_average() {
       local load_1min=$(uptime | awk -F'load average:' '{print $2}' | awk -F',' '{print $1}' | tr -d ' ')
       
       log_debug "Load average (1min): $load_1min"
       
       if (( $(echo "$load_1min > $LOAD_THRESHOLD" | bc -l) )); then
           add_warning "High load average: $load_1min (threshold: $LOAD_THRESHOLD)"
       fi
       
       echo "$load_1min"
   }
   
   check_services() {
       local critical_services=("sshd" "systemd-logind" "NetworkManager")
       
       for service in "${critical_services[@]}"; do
           if systemctl is-active "$service" >/dev/null 2>&1; then
               log_debug "Service $service: RUNNING"
           else
               add_error "Critical service not running: $service"
           fi
       done
   }
   
   generate_report() {
       local report_file="/tmp/system-monitor-report-$(date +%Y%m%d_%H%M%S).txt"
       
       cat > "$report_file" << EOF
   SYSTEM MONITORING REPORT
   Generated: $(date)
   Hostname: $(hostname)
   Uptime: $(uptime)
   
   RESOURCE USAGE:
   CPU Usage: $(check_cpu_usage)%
   Memory Usage: $(check_memory_usage)%
   Load Average: $(check_load_average)
   
   DISK USAGE:
   $(df -h | grep -E '^/dev/')
   
   NETWORK INTERFACES:
   $(ip addr show | grep -E '^[0-9]+:' | awk '{print $2}' | tr -d ':')
   
   RUNNING PROCESSES: $(ps aux | wc -l)
   
   ERRORS: $ERROR_COUNT
   WARNINGS: $WARNING_COUNT
   EOF
       
       log_info "System monitoring report generated: $report_file"
       echo "$report_file"
   }
   
   # Main monitoring function
   main() {
       log_info "Starting system monitoring"
       
       start_timer
       
       # Load configuration
       load_config
       
       # Perform checks
       check_cpu_usage >/dev/null
       check_memory_usage >/dev/null
       check_disk_usage
       check_load_average >/dev/null
       check_services
       
       # Generate report
       local report_file=$(generate_report)
       
       end_timer "System monitoring"
       
       # Check for errors and warnings
       check_errors
       
       log_info "System monitoring completed. Report: $report_file"
   }
   
   # Execute main function
   main "$@"

2. Create user management script:
   # vim /opt/scripts/user-management.sh
   
   #!/bin/bash
   #
   # Advanced User Management Script
   #
   
   # Source function libraries
   source /opt/scripts/functions/advanced-functions.sh
   source /opt/scripts/functions/error-handling.sh
   source /opt/scripts/functions/parameter-handling.sh
   
   # Script configuration
   readonly SCRIPT_NAME="user-management"
   readonly CONFIG_FILE="/opt/scripts/configs/user-management.conf"
   readonly LOG_FILE="/var/log/user-management.log"
   
   # Default settings
   DEFAULT_SHELL="/bin/bash"
   DEFAULT_HOME_DIR="/home"
   PASSWORD_LENGTH=12
   
   # User management functions
   create_user() {
       local username="$1"
       local full_name="$2"
       local groups="$3"
       local shell="${4:-$DEFAULT_SHELL}"
       
       log_info "Creating user: $username"
       
       # Validate username
       if ! [[ "$username" =~ ^[a-z][a-z0-9_-]*$ ]]; then
           add_error "Invalid username format: $username"
           return 1
       fi
       
       # Check if user already exists
       if id "$username" >/dev/null 2>&1; then
           add_warning "User already exists: $username"
           return 1
       fi
       
       # Create user
       local cmd="useradd -m -s '$shell' -c '$full_name' '$username'"
       if ! execute_command "$cmd" "Creating user $username"; then
           add_error "Failed to create user: $username"
           return 1
       fi
       
       # Add to groups
       if [ -n "$groups" ]; then
           local cmd="usermod -a -G '$groups' '$username'"
           execute_command "$cmd" "Adding user $username to groups: $groups"
       fi
       
       # Generate password
       local password=$(generate_password)
       echo "$username:$password" | chpasswd
       
       log_info "User created successfully: $username"
       log_info "Generated password: $password"
       
       return 0
   }
   
   delete_user() {
       local username="$1"
       local remove_home="${2:-true}"
       
       log_info "Deleting user: $username"
       
       # Check if user exists
       if ! id "$username" >/dev/null 2>&1; then
           add_error "User does not exist: $username"
           return 1
       fi
       
       # Confirm deletion
       if ! confirm "Delete user $username?"; then
           log_info "User deletion cancelled"
           return 0
       fi
       
       # Backup user data
       local backup_file=$(backup_user_data "$username")
       
       # Delete user
       local cmd="userdel"
       if [ "$remove_home" = true ]; then
           cmd="$cmd -r"
       fi
       cmd="$cmd '$username'"
       
       if execute_command "$cmd" "Deleting user $username"; then
           log_info "User deleted successfully: $username"
           log_info "User data backed up to: $backup_file"
       else
           add_error "Failed to delete user: $username"
           return 1
       fi
       
       return 0
   }
   
   modify_user() {
       local username="$1"
       local attribute="$2"
       local value="$3"
       
       log_info "Modifying user $username: $attribute = $value"
       
       # Check if user exists
       if ! id "$username" >/dev/null 2>&1; then
           add_error "User does not exist: $username"
           return 1
       fi
       
       case "$attribute" in
           "shell")
               execute_command "usermod -s '$value' '$username'" "Changing shell for $username"
               ;;
           "groups")
               execute_command "usermod -G '$value' '$username'" "Setting groups for $username"
               ;;
           "home")
               execute_command "usermod -d '$value' -m '$username'" "Moving home directory for $username"
               ;;
           "comment")
               execute_command "usermod -c '$value' '$username'" "Setting comment for $username"
               ;;
           *)
               add_error "Unknown attribute: $attribute"
               return 1
               ;;
       esac
   }
   
   generate_password() {
       local length="${1:-$PASSWORD_LENGTH}"
       openssl rand -base64 32 | tr -d "=+/" | cut -c1-$length
   }
   
   backup_user_data() {
       local username="$1"
       local backup_dir="/tmp/user-backups"
       local timestamp=$(date +%Y%m%d_%H%M%S)
       
       mkdir -p "$backup_dir"
       
       local backup_file="$backup_dir/${username}-backup-${timestamp}.tar.gz"
       
       if [ -d "/home/$username" ]; then
           tar -czf "$backup_file" -C /home "$username" 2>/dev/null
           log_info "User data backed up: $backup_file"
           echo "$backup_file"
       fi
   }
   
   list_users() {
       local filter="${1:-all}"
       
       case "$filter" in
           "system")
               awk -F: '$3 < 1000 {print $1}' /etc/passwd
               ;;
           "regular")
               awk -F: '$3 >= 1000 && $3 != 65534 {print $1}' /etc/passwd
               ;;
           "all")
               awk -F: '{print $1}' /etc/passwd
               ;;
           *)
               add_error "Invalid filter: $filter"
               return 1
               ;;
       esac
   }
   
   # Main function
   main() {
       local action="$1"
       shift
       
       case "$action" in
           "create")
               create_user "$@"
               ;;
           "delete")
               delete_user "$@"
               ;;
           "modify")
               modify_user "$@"
               ;;
           "list")
               list_users "$@"
               ;;
           *)
               echo "Usage: $0 {create|delete|modify|list} [options]"
               exit 1
               ;;
       esac
       
       check_errors
   }
   
   # Execute main function
   main "$@"

PART E: AUTOMATION FRAMEWORKS
-----------------------------

1. Create task automation framework:
   # vim /opt/scripts/task-automation.sh
   
   #!/bin/bash
   #
   # Task Automation Framework
   #
   
   # Source function libraries
   source /opt/scripts/functions/advanced-functions.sh
   source /opt/scripts/functions/error-handling.sh
   
   # Task definitions
   declare -A TASKS
   declare -A TASK_DEPENDENCIES
   declare -A TASK_STATUS
   
   # Task registration
   register_task() {
       local task_name="$1"
       local task_function="$2"
       local dependencies="$3"
       
       TASKS["$task_name"]="$task_function"
       TASK_DEPENDENCIES["$task_name"]="$dependencies"
       TASK_STATUS["$task_name"]="pending"
       
       log_debug "Registered task: $task_name"
   }
   
   # Dependency resolution
   resolve_dependencies() {
       local task="$1"
       local resolved=()
       local unresolved=()
       
       resolve_task_deps "$task" resolved unresolved
       echo "${resolved[@]}"
   }
   
   resolve_task_deps() {
       local task="$1"
       local -n resolved_ref=$2
       local -n unresolved_ref=$3
       
       unresolved_ref+=("$task")
       
       local deps="${TASK_DEPENDENCIES[$task]}"
       if [ -n "$deps" ]; then
           for dep in $deps; do
               if ! array_contains "$dep" "${resolved_ref[@]}"; then
                   if array_contains "$dep" "${unresolved_ref[@]}"; then
                       die $E_GENERAL "Circular dependency detected: $task -> $dep"
                   fi
                   resolve_task_deps "$dep" resolved_ref unresolved_ref
               fi
           done
       fi
       
       resolved_ref+=("$task")
       
       # Remove from unresolved
       local temp_unresolved=()
       for item in "${unresolved_ref[@]}"; do
           if [ "$item" != "$task" ]; then
               temp_unresolved+=("$item")
           fi
       done
       unresolved_ref=("${temp_unresolved[@]}")
   }
   
   # Task execution
   execute_task() {
       local task_name="$1"
       
       if [ "${TASK_STATUS[$task_name]}" = "completed" ]; then
           log_debug "Task already completed: $task_name"
           return 0
       fi
       
       log_info "Executing task: $task_name"
       TASK_STATUS["$task_name"]="running"
       
       local task_function="${TASKS[$task_name]}"
       
       if [ -n "$task_function" ]; then
           if eval "$task_function"; then
               TASK_STATUS["$task_name"]="completed"
               log_info "Task completed successfully: $task_name"
               return 0
           else
               TASK_STATUS["$task_name"]="failed"
               add_error "Task failed: $task_name"
               return 1
           fi
       else
           add_error "Task function not found: $task_name"
           return 1
       fi
   }
   
   # Execute task with dependencies
   execute_task_with_deps() {
       local task="$1"
       local execution_order=($(resolve_dependencies "$task"))
       
       log_info "Execution order: ${execution_order[*]}"
       
       for task_name in "${execution_order[@]}"; do
           execute_task "$task_name" || return 1
       done
   }
   
   # Task status reporting
   report_task_status() {
       echo "Task Status Report:"
       echo "==================="
       
       for task in "${!TASKS[@]}"; do
           printf "%-20s: %s\n" "$task" "${TASK_STATUS[$task]}"
       done
   }

2. Create configuration deployment script:
   # vim /opt/scripts/config-deployment.sh
   
   #!/bin/bash
   #
   # Configuration Deployment Script
   #
   
   # Source function libraries
   source /opt/scripts/functions/advanced-functions.sh
   source /opt/scripts/functions/error-handling.sh
   source /opt/scripts/task-automation.sh
   
   # Configuration deployment tasks
   task_backup_configs() {
       log_info "Backing up current configurations"
       
       local backup_dir="/tmp/config-backup-$(date +%Y%m%d_%H%M%S)"
       mkdir -p "$backup_dir"
       
       local config_files=("/etc/httpd/conf/httpd.conf" "/etc/ssh/sshd_config" "/etc/hosts")
       
       for config in "${config_files[@]}"; do
           if [ -f "$config" ]; then
               cp "$config" "$backup_dir/"
               log_debug "Backed up: $config"
           fi
       done
       
       log_info "Configuration backup completed: $backup_dir"
   }
   
   task_validate_configs() {
       log_info "Validating configuration files"
       
       # Validate Apache configuration
       if command_exists httpd; then
           execute_command "httpd -t" "Validating Apache configuration"
       fi
       
       # Validate SSH configuration
       execute_command "sshd -t" "Validating SSH configuration"
       
       log_info "Configuration validation completed"
   }
   
   task_deploy_configs() {
       log_info "Deploying new configurations"
       
       local source_dir="/opt/scripts/configs/templates"
       local configs=(
           "httpd.conf:/etc/httpd/conf/httpd.conf"
           "sshd_config:/etc/ssh/sshd_config"
       )
       
       for config_mapping in "${configs[@]}"; do
           local source_file="${config_mapping%%:*}"
           local target_file="${config_mapping##*:}"
           
           if [ -f "$source_dir/$source_file" ]; then
               execute_command "cp '$source_dir/$source_file' '$target_file'" "Deploying $source_file"
           fi
       done
       
       log_info "Configuration deployment completed"
   }
   
   task_restart_services() {
       log_info "Restarting services"
       
       local services=("httpd" "sshd")
       
       for service in "${services[@]}"; do
           if systemctl is-enabled "$service" >/dev/null 2>&1; then
               execute_command "systemctl restart '$service'" "Restarting $service"
           fi
       done
       
       log_info "Service restart completed"
   }
   
   task_verify_deployment() {
       log_info "Verifying deployment"
       
       # Check service status
       local services=("httpd" "sshd")
       
       for service in "${services[@]}"; do
           if systemctl is-active "$service" >/dev/null 2>&1; then
               log_info "Service $service: RUNNING"
           else
               add_error "Service $service: NOT RUNNING"
           fi
       done
       
       # Test connectivity
       if check_connectivity; then
           log_info "Network connectivity: OK"
       else
           add_warning "Network connectivity: FAILED"
       fi
       
       log_info "Deployment verification completed"
   }
   
   # Register tasks
   register_task "backup" "task_backup_configs" ""
   register_task "validate" "task_validate_configs" "backup"
   register_task "deploy" "task_deploy_configs" "validate"
   register_task "restart" "task_restart_services" "deploy"
   register_task "verify" "task_verify_deployment" "restart"
   
   # Main function
   main() {
       local target_task="${1:-verify}"
       
       log_info "Starting configuration deployment"
       
       if execute_task_with_deps "$target_task"; then
           log_info "Configuration deployment completed successfully"
       else
           log_error "Configuration deployment failed"
       fi
       
       report_task_status
       check_errors
   }
   
   # Execute main function
   main "$@"

PART F: TESTING AND VALIDATION
-------------------------------

1. Test advanced script template:
   # cp /opt/scripts/templates/advanced-script-template.sh /tmp/test-script.sh
   # chmod +x /tmp/test-script.sh
   # /tmp/test-script.sh --help
   # /tmp/test-script.sh --version
   # /tmp/test-script.sh --verbose --debug

2. Test function libraries:
   # source /opt/scripts/functions/advanced-functions.sh
   # command_exists "ls" && echo "Command exists test: PASSED"
   # validate_integer "123" 1 200 && echo "Integer validation test: PASSED"
   # check_connectivity "8.8.8.8" && echo "Connectivity test: PASSED"

3. Test error handling:
   # source /opt/scripts/functions/error-handling.sh
   # add_error "Test error message"
   # add_warning "Test warning message"
   # echo "Error count: $ERROR_COUNT, Warning count: $WARNING_COUNT"

4. Test system monitoring script:
   # chmod +x /opt/scripts/system-monitor.sh
   # /opt/scripts/system-monitor.sh
   # cat /var/log/system-monitor.log

5. Test user management script:
   # chmod +x /opt/scripts/user-management.sh
   # /opt/scripts/user-management.sh list regular
   # /opt/scripts/user-management.sh create testuser "Test User" "users"

6. Test task automation:
   # chmod +x /opt/scripts/config-deployment.sh
   # /opt/scripts/config-deployment.sh backup

7. Create test configuration:
   # mkdir -p /opt/scripts/configs
   # /opt/scripts/functions/config-management.sh generate_config_template /opt/scripts/configs/test.conf

TROUBLESHOOTING COMMANDS:
-------------------------
# bash -x /opt/scripts/script-name.sh  # Debug mode
# shellcheck /opt/scripts/script-name.sh  # Syntax checking
# tail -f /var/log/script-name.log  # Monitor logs
# ps aux | grep script-name  # Check running scripts

EXPECTED RESULTS:
-----------------
- Advanced script template with comprehensive features
- Robust error handling and debugging capabilities
- Advanced parameter processing and validation
- Reusable function libraries for common tasks
- System administration automation scripts
- Task automation framework with dependency resolution
- Configuration management and deployment automation

VALIDATION CHECKLIST:
---------------------
□ Advanced script template functional
□ Function libraries working correctly
□ Error handling and debugging operational
□ Parameter validation working
□ System monitoring script running
□ User management script functional
□ Task automation framework operational
□ Configuration deployment working
□ All scripts properly documented
□ Logging and debugging features active

CLEANUP:
--------
# rm -rf /opt/scripts
# rm /tmp/test-script.sh
# rm /var/log/system-monitor.log
# rm /var/log/user-management.log
# userdel -r testuser 2>/dev/null
