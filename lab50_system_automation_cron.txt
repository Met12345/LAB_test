RHCE RH254 HANDS-ON LAB: SYSTEM AUTOMATION WITH CRON
===================================================

LAB OBJECTIVE:
Configure comprehensive system automation using cron, including advanced scheduling, job management, monitoring, and enterprise-grade automated task execution

PREREQUISITES:
- RHEL 8/9 system with root access
- Understanding of cron syntax and scheduling
- Basic knowledge of shell scripting
- Familiarity with system administration tasks

LAB SCENARIO:
Implement enterprise system automation using cron with advanced scheduling patterns, job monitoring, error handling, and automated system maintenance tasks.

EQUIPMENT NEEDED:
- RHEL system (192.168.1.20)
- System utilities for automated tasks
- Log storage for cron job monitoring

LAB TASKS:

PART A: ADVANCED CRON CONFIGURATION
------------------------------------

1. Configure cron service and security:
   # systemctl enable crond
   # systemctl start crond
   # systemctl status crond

2. Configure cron security settings:
   # vim /etc/cron.allow
   root
   admin
   operator
   
   # vim /etc/cron.deny
   guest
   nobody
   
   # chmod 600 /etc/cron.allow /etc/cron.deny

3. Create cron directories structure:
   # mkdir -p /opt/cron/{scripts,logs,configs,backups}
   # chmod 755 /opt/cron
   # chmod 700 /opt/cron/scripts

4. Configure cron logging:
   # vim /etc/rsyslog.d/cron.conf
   # Cron logging configuration
   cron.*    /var/log/cron-detailed.log
   
   # systemctl restart rsyslog

5. Create cron job template:
   # vim /opt/cron/scripts/cron-job-template.sh
   
   #!/bin/bash
   #
   # Cron Job Template
   # Usage: Standardized template for cron jobs
   #
   
   # Job metadata
   JOB_NAME="$(basename "$0" .sh)"
   JOB_START_TIME=$(date +%s)
   LOG_FILE="/opt/cron/logs/${JOB_NAME}.log"
   LOCK_FILE="/var/run/${JOB_NAME}.lock"
   
   # Logging function
   log_message() {
       local level="$1"
       local message="$2"
       echo "$(date '+%Y-%m-%d %H:%M:%S') [$level] $message" >> "$LOG_FILE"
   }
   
   # Lock mechanism to prevent concurrent execution
   acquire_lock() {
       if [ -f "$LOCK_FILE" ]; then
           local pid=$(cat "$LOCK_FILE")
           if kill -0 "$pid" 2>/dev/null; then
               log_message "WARN" "Job already running with PID $pid"
               exit 1
           else
               log_message "INFO" "Removing stale lock file"
               rm -f "$LOCK_FILE"
           fi
       fi
       
       echo $$ > "$LOCK_FILE"
       log_message "INFO" "Lock acquired"
   }
   
   # Cleanup function
   cleanup() {
       rm -f "$LOCK_FILE"
       local duration=$(($(date +%s) - JOB_START_TIME))
       log_message "INFO" "Job completed in ${duration}s"
   }
   
   # Set up cleanup on exit
   trap cleanup EXIT
   
   # Main job function
   main() {
       log_message "INFO" "Starting $JOB_NAME"
       
       # Acquire lock
       acquire_lock
       
       # Job logic goes here
       log_message "INFO" "Executing job logic"
       
       # Example job tasks
       echo "Job executed at $(date)" >> "/tmp/${JOB_NAME}-output.txt"
       
       log_message "INFO" "Job logic completed"
   }
   
   # Execute main function
   main "$@"

PART B: SYSTEM MAINTENANCE AUTOMATION
--------------------------------------

1. Create system cleanup automation:
   # vim /opt/cron/scripts/system-cleanup.sh
   
   #!/bin/bash
   #
   # System Cleanup Automation
   #
   
   JOB_NAME="system-cleanup"
   LOG_FILE="/opt/cron/logs/${JOB_NAME}.log"
   LOCK_FILE="/var/run/${JOB_NAME}.lock"
   
   # Configuration
   TEMP_RETENTION_DAYS=7
   LOG_RETENTION_DAYS=30
   CACHE_RETENTION_DAYS=14
   
   log_message() {
       echo "$(date '+%Y-%m-%d %H:%M:%S') [$1] $2" >> "$LOG_FILE"
   }
   
   acquire_lock() {
       if [ -f "$LOCK_FILE" ]; then
           local pid=$(cat "$LOCK_FILE")
           if kill -0 "$pid" 2>/dev/null; then
               log_message "WARN" "Cleanup already running with PID $pid"
               exit 1
           fi
       fi
       echo $$ > "$LOCK_FILE"
   }
   
   cleanup_temp_files() {
       log_message "INFO" "Cleaning temporary files older than $TEMP_RETENTION_DAYS days"
       
       local cleaned=0
       
       # Clean /tmp
       find /tmp -type f -atime +$TEMP_RETENTION_DAYS -delete 2>/dev/null
       cleaned=$((cleaned + $(find /tmp -type f -atime +$TEMP_RETENTION_DAYS | wc -l)))
       
       # Clean /var/tmp
       find /var/tmp -type f -atime +$TEMP_RETENTION_DAYS -delete 2>/dev/null
       cleaned=$((cleaned + $(find /var/tmp -type f -atime +$TEMP_RETENTION_DAYS | wc -l)))
       
       log_message "INFO" "Cleaned $cleaned temporary files"
   }
   
   cleanup_log_files() {
       log_message "INFO" "Cleaning log files older than $LOG_RETENTION_DAYS days"
       
       local cleaned=0
       
       # Clean old log files
       find /var/log -name "*.log" -type f -mtime +$LOG_RETENTION_DAYS -delete 2>/dev/null
       cleaned=$((cleaned + $(find /var/log -name "*.log" -type f -mtime +$LOG_RETENTION_DAYS | wc -l)))
       
       # Clean rotated logs
       find /var/log -name "*.log.*" -type f -mtime +$LOG_RETENTION_DAYS -delete 2>/dev/null
       
       log_message "INFO" "Cleaned $cleaned log files"
   }
   
   cleanup_package_cache() {
       log_message "INFO" "Cleaning package cache"
       
       # Clean DNF cache
       dnf clean all >/dev/null 2>&1
       
       # Clean old kernels (keep last 2)
       package-cleanup --oldkernels --count=2 -y >/dev/null 2>&1
       
       log_message "INFO" "Package cache cleaned"
   }
   
   cleanup_user_caches() {
       log_message "INFO" "Cleaning user caches older than $CACHE_RETENTION_DAYS days"
       
       # Clean user cache directories
       find /home/*/.cache -type f -atime +$CACHE_RETENTION_DAYS -delete 2>/dev/null
       find /root/.cache -type f -atime +$CACHE_RETENTION_DAYS -delete 2>/dev/null
       
       log_message "INFO" "User caches cleaned"
   }
   
   generate_cleanup_report() {
       local report_file="/opt/cron/logs/cleanup-report-$(date +%Y%m%d).txt"
       
       cat > "$report_file" << EOF
   System Cleanup Report
   Generated: $(date)
   
   Disk Usage Before Cleanup:
   $(df -h)
   
   Cleanup Summary:
   - Temporary files: Cleaned files older than $TEMP_RETENTION_DAYS days
   - Log files: Cleaned files older than $LOG_RETENTION_DAYS days
   - Package cache: Cleaned
   - User caches: Cleaned files older than $CACHE_RETENTION_DAYS days
   
   Disk Usage After Cleanup:
   $(df -h)
   EOF
       
       log_message "INFO" "Cleanup report generated: $report_file"
   }
   
   main() {
       log_message "INFO" "Starting system cleanup"
       
       acquire_lock
       
       cleanup_temp_files
       cleanup_log_files
       cleanup_package_cache
       cleanup_user_caches
       generate_cleanup_report
       
       rm -f "$LOCK_FILE"
       log_message "INFO" "System cleanup completed"
   }
   
   main "$@"

2. Create backup automation script:
   # vim /opt/cron/scripts/backup-automation.sh
   
   #!/bin/bash
   #
   # Backup Automation Script
   #
   
   JOB_NAME="backup-automation"
   LOG_FILE="/opt/cron/logs/${JOB_NAME}.log"
   LOCK_FILE="/var/run/${JOB_NAME}.lock"
   BACKUP_DIR="/opt/cron/backups"
   
   # Configuration
   BACKUP_SOURCES="/etc /home /opt /var/www"
   RETENTION_DAYS=30
   
   log_message() {
       echo "$(date '+%Y-%m-%d %H:%M:%S') [$1] $2" >> "$LOG_FILE"
   }
   
   acquire_lock() {
       if [ -f "$LOCK_FILE" ]; then
           local pid=$(cat "$LOCK_FILE")
           if kill -0 "$pid" 2>/dev/null; then
               log_message "WARN" "Backup already running with PID $pid"
               exit 1
           fi
       fi
       echo $$ > "$LOCK_FILE"
   }
   
   create_backup() {
       local backup_type="$1"
       local timestamp=$(date +%Y%m%d_%H%M%S)
       local backup_file="$BACKUP_DIR/${backup_type}-backup-${timestamp}.tar.gz"
       
       mkdir -p "$BACKUP_DIR"
       
       log_message "INFO" "Creating $backup_type backup: $backup_file"
       
       case "$backup_type" in
           "daily")
               tar --exclude='*.tmp' --exclude='*.cache' \
                   -czf "$backup_file" $BACKUP_SOURCES 2>/dev/null
               ;;
           "weekly")
               tar --exclude='*.tmp' --exclude='*.cache' --exclude='*.log' \
                   -czf "$backup_file" $BACKUP_SOURCES 2>/dev/null
               ;;
           "config")
               tar -czf "$backup_file" /etc 2>/dev/null
               ;;
       esac
       
       if [ $? -eq 0 ]; then
           local size=$(du -h "$backup_file" | cut -f1)
           log_message "INFO" "Backup created successfully: $backup_file ($size)"
           
           # Create checksum
           sha256sum "$backup_file" > "${backup_file}.sha256"
           
           return 0
       else
           log_message "ERROR" "Backup creation failed: $backup_file"
           return 1
       fi
   }
   
   cleanup_old_backups() {
       log_message "INFO" "Cleaning backups older than $RETENTION_DAYS days"
       
       local cleaned=0
       find "$BACKUP_DIR" -name "*.tar.gz" -mtime +$RETENTION_DAYS -delete 2>/dev/null
       find "$BACKUP_DIR" -name "*.sha256" -mtime +$RETENTION_DAYS -delete 2>/dev/null
       
       log_message "INFO" "Old backups cleaned"
   }
   
   verify_backup() {
       local backup_file="$1"
       
       if [ -f "${backup_file}.sha256" ]; then
           if sha256sum -c "${backup_file}.sha256" >/dev/null 2>&1; then
               log_message "INFO" "Backup verification successful: $(basename "$backup_file")"
               return 0
           else
               log_message "ERROR" "Backup verification failed: $(basename "$backup_file")"
               return 1
           fi
       else
           log_message "WARN" "No checksum file found for: $(basename "$backup_file")"
           return 1
       fi
   }
   
   main() {
       local backup_type="${1:-daily}"
       
       log_message "INFO" "Starting backup automation ($backup_type)"
       
       acquire_lock
       
       if create_backup "$backup_type"; then
           local latest_backup=$(find "$BACKUP_DIR" -name "*backup*.tar.gz" -type f | sort | tail -1)
           verify_backup "$latest_backup"
       fi
       
       cleanup_old_backups
       
       rm -f "$LOCK_FILE"
       log_message "INFO" "Backup automation completed"
   }
   
   main "$@"
3. Create system monitoring automation:
   # vim /opt/cron/scripts/system-monitoring.sh
   
   #!/bin/bash
   #
   # System Monitoring Automation
   #
   
   JOB_NAME="system-monitoring"
   LOG_FILE="/opt/cron/logs/${JOB_NAME}.log"
   LOCK_FILE="/var/run/${JOB_NAME}.lock"
   
   # Thresholds
   CPU_THRESHOLD=80
   MEMORY_THRESHOLD=85
   DISK_THRESHOLD=90
   LOAD_THRESHOLD=2.0
   
   log_message() {
       echo "$(date '+%Y-%m-%d %H:%M:%S') [$1] $2" >> "$LOG_FILE"
   }
   
   acquire_lock() {
       if [ -f "$LOCK_FILE" ]; then
           local pid=$(cat "$LOCK_FILE")
           if kill -0 "$pid" 2>/dev/null; then
               log_message "WARN" "Monitoring already running with PID $pid"
               exit 1
           fi
       fi
       echo $$ > "$LOCK_FILE"
   }
   
   check_cpu_usage() {
       local cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1 | cut -d'.' -f1)
       
       if [ "$cpu_usage" -gt "$CPU_THRESHOLD" ]; then
           log_message "ALERT" "High CPU usage: ${cpu_usage}% (threshold: ${CPU_THRESHOLD}%)"
           
           # Get top CPU processes
           local top_procs=$(ps aux --sort=-%cpu | head -6 | tail -5 | awk '{print $11}' | tr '\n' ' ')
           log_message "INFO" "Top CPU processes: $top_procs"
           
           return 1
       else
           log_message "INFO" "CPU usage normal: ${cpu_usage}%"
           return 0
       fi
   }
   
   check_memory_usage() {
       local memory_usage=$(free | grep Mem | awk '{printf("%.0f", $3/$2 * 100.0)}')
       
       if [ "$memory_usage" -gt "$MEMORY_THRESHOLD" ]; then
           log_message "ALERT" "High memory usage: ${memory_usage}% (threshold: ${MEMORY_THRESHOLD}%)"
           
           # Get top memory processes
           local top_procs=$(ps aux --sort=-%mem | head -6 | tail -5 | awk '{print $11}' | tr '\n' ' ')
           log_message "INFO" "Top memory processes: $top_procs"
           
           return 1
       else
           log_message "INFO" "Memory usage normal: ${memory_usage}%"
           return 0
       fi
   }
   
   check_disk_usage() {
       local alerts=0
       
       df -h | grep -E '^/dev/' | while read line; do
           local usage=$(echo $line | awk '{print $5}' | cut -d'%' -f1)
           local filesystem=$(echo $line | awk '{print $6}')
           
           if [ "$usage" -gt "$DISK_THRESHOLD" ]; then
               log_message "ALERT" "High disk usage: $filesystem ${usage}% (threshold: ${DISK_THRESHOLD}%)"
               alerts=$((alerts + 1))
           else
               log_message "INFO" "Disk usage normal: $filesystem ${usage}%"
           fi
       done
       
       return $alerts
   }
   
   check_services() {
       local critical_services=("sshd" "systemd-logind" "crond")
       local failed_services=0
       
       for service in "${critical_services[@]}"; do
           if systemctl is-active "$service" >/dev/null 2>&1; then
               log_message "INFO" "Service $service: RUNNING"
           else
               log_message "ALERT" "Service $service: NOT RUNNING"
               failed_services=$((failed_services + 1))
               
               # Attempt to restart service
               log_message "INFO" "Attempting to restart $service"
               systemctl start "$service" >/dev/null 2>&1
               
               if systemctl is-active "$service" >/dev/null 2>&1; then
                   log_message "INFO" "Service $service restarted successfully"
               else
                   log_message "ERROR" "Failed to restart service $service"
               fi
           fi
       done
       
       return $failed_services
   }
   
   generate_monitoring_report() {
       local report_file="/opt/cron/logs/monitoring-report-$(date +%Y%m%d_%H%M).txt"
       
       cat > "$report_file" << EOF
   System Monitoring Report
   Generated: $(date)
   Hostname: $(hostname)
   
   System Load:
   $(uptime)
   
   CPU Usage:
   $(top -bn1 | grep "Cpu(s)")
   
   Memory Usage:
   $(free -h)
   
   Disk Usage:
   $(df -h | grep -E '^/dev/')
   
   Network Interfaces:
   $(ip addr show | grep -E '^[0-9]+:' | awk '{print $2}' | tr -d ':')
   
   Running Processes: $(ps aux | wc -l)
   EOF
       
       log_message "INFO" "Monitoring report generated: $report_file"
   }
   
   main() {
       log_message "INFO" "Starting system monitoring"
       
       acquire_lock
       
       local alerts=0
       
       check_cpu_usage || alerts=$((alerts + 1))
       check_memory_usage || alerts=$((alerts + 1))
       check_disk_usage || alerts=$((alerts + 1))
       check_services || alerts=$((alerts + 1))
       
       generate_monitoring_report
       
       if [ $alerts -gt 0 ]; then
           log_message "WARN" "System monitoring completed with $alerts alerts"
       else
           log_message "INFO" "System monitoring completed - all checks passed"
       fi
       
       rm -f "$LOCK_FILE"
   }
   
   main "$@"

PART C: ADVANCED CRON SCHEDULING
---------------------------------

1. Create comprehensive cron schedule:
   # vim /etc/cron.d/system-automation
   
   # System Automation Cron Jobs
   # Format: minute hour day month weekday user command
   
   # System cleanup - daily at 2 AM
   0 2 * * * root /opt/cron/scripts/system-cleanup.sh
   
   # System monitoring - every 15 minutes
   */15 * * * * root /opt/cron/scripts/system-monitoring.sh
   
   # Daily backup - every day at 3 AM
   0 3 * * * root /opt/cron/scripts/backup-automation.sh daily
   
   # Weekly backup - Sunday at 4 AM
   0 4 * * 0 root /opt/cron/scripts/backup-automation.sh weekly
   
   # Configuration backup - daily at 1 AM
   0 1 * * * root /opt/cron/scripts/backup-automation.sh config
   
   # Log rotation check - daily at 6 AM
   0 6 * * * root /usr/sbin/logrotate /etc/logrotate.conf
   
   # Update system package cache - daily at 5 AM
   0 5 * * * root /usr/bin/dnf makecache >/dev/null 2>&1
   
   # Check for security updates - daily at 7 AM
   0 7 * * * root /opt/cron/scripts/security-updates.sh
   
   # Database maintenance - Sunday at 5 AM
   0 5 * * 0 root /opt/cron/scripts/database-maintenance.sh
   
   # Network connectivity check - every 5 minutes
   */5 * * * * root /opt/cron/scripts/network-check.sh

2. Create user-specific cron jobs:
   # crontab -e
   
   # User-level automation jobs
   # Personal backup - daily at 11 PM
   0 23 * * * /opt/cron/scripts/user-backup.sh
   
   # Clean user temp files - weekly on Saturday at 10 PM
   0 22 * * 6 find $HOME/tmp -type f -mtime +7 -delete 2>/dev/null
   
   # Update personal scripts - monthly on 1st at 9 PM
   0 21 1 * * /opt/cron/scripts/update-personal-scripts.sh

3. Create advanced scheduling examples:
   # vim /opt/cron/configs/advanced-schedules.txt
   
   # Advanced Cron Scheduling Examples
   
   # Every 30 seconds (using sleep in script)
   * * * * * /opt/cron/scripts/high-frequency.sh
   
   # Business hours only (9 AM to 5 PM, Monday to Friday)
   0 9-17 * * 1-5 /opt/cron/scripts/business-hours-task.sh
   
   # Every 2 hours during business days
   0 */2 * * 1-5 /opt/cron/scripts/bi-hourly-task.sh
   
   # First Monday of every month at 8 AM
   0 8 1-7 * 1 /opt/cron/scripts/first-monday-task.sh
   
   # Last day of every month at 11 PM
   0 23 28-31 * * [ $(date -d tomorrow +\%d) -eq 1 ] && /opt/cron/scripts/month-end-task.sh
   
   # Every 15 minutes between 6 AM and 10 PM
   */15 6-22 * * * /opt/cron/scripts/daytime-frequent-task.sh
   
   # Quarterly on the 1st at 6 AM (Jan, Apr, Jul, Oct)
   0 6 1 1,4,7,10 * /opt/cron/scripts/quarterly-task.sh

PART D: CRON JOB MONITORING AND MANAGEMENT
-------------------------------------------

1. Create cron job monitoring system:
   # vim /opt/cron/scripts/cron-monitor.sh
   
   #!/bin/bash
   #
   # Cron Job Monitoring System
   #
   
   JOB_NAME="cron-monitor"
   LOG_FILE="/opt/cron/logs/${JOB_NAME}.log"
   MONITOR_DIR="/opt/cron/logs"
   
   log_message() {
       echo "$(date '+%Y-%m-%d %H:%M:%S') [$1] $2" >> "$LOG_FILE"
   }
   
   check_cron_service() {
       if systemctl is-active crond >/dev/null 2>&1; then
           log_message "INFO" "Cron service is running"
           return 0
       else
           log_message "ERROR" "Cron service is not running"
           
           # Attempt to start cron service
           systemctl start crond
           if systemctl is-active crond >/dev/null 2>&1; then
               log_message "INFO" "Cron service started successfully"
               return 0
           else
               log_message "ERROR" "Failed to start cron service"
               return 1
           fi
       fi
   }
   
   analyze_cron_logs() {
       local cron_log="/var/log/cron"
       local today=$(date +%Y-%m-%d)
       
       if [ -f "$cron_log" ]; then
           # Count successful jobs today
           local successful_jobs=$(grep "$today" "$cron_log" | grep -c "CMD")
           
           # Count failed jobs today
           local failed_jobs=$(grep "$today" "$cron_log" | grep -c "FAILED")
           
           log_message "INFO" "Today's cron jobs - Successful: $successful_jobs, Failed: $failed_jobs"
           
           # Check for recent errors
           local recent_errors=$(grep "$today" "$cron_log" | grep -i "error\|failed" | tail -5)
           if [ -n "$recent_errors" ]; then
               log_message "WARN" "Recent cron errors detected"
               echo "$recent_errors" >> "$LOG_FILE"
           fi
       else
           log_message "WARN" "Cron log file not found: $cron_log"
       fi
   }
   
   check_job_completion() {
       local job_logs_dir="/opt/cron/logs"
       local current_hour=$(date +%H)
       local alerts=0
       
       # Define expected jobs and their frequencies
       declare -A expected_jobs
       expected_jobs["system-cleanup"]="daily"
       expected_jobs["backup-automation"]="daily"
       expected_jobs["system-monitoring"]="hourly"
       
       for job in "${!expected_jobs[@]}"; do
           local frequency="${expected_jobs[$job]}"
           local job_log="$job_logs_dir/${job}.log"
           
           if [ -f "$job_log" ]; then
               case "$frequency" in
                   "hourly")
                       # Check if job ran in the last hour
                       local last_run=$(grep "$(date +%Y-%m-%d\ %H)" "$job_log" | tail -1)
                       if [ -z "$last_run" ]; then
                           log_message "WARN" "Job $job has not run in the last hour"
                           alerts=$((alerts + 1))
                       fi
                       ;;
                   "daily")
                       # Check if job ran today
                       local last_run=$(grep "$(date +%Y-%m-%d)" "$job_log" | tail -1)
                       if [ -z "$last_run" ]; then
                           log_message "WARN" "Job $job has not run today"
                           alerts=$((alerts + 1))
                       fi
                       ;;
               esac
           else
               log_message "ERROR" "Log file not found for job: $job"
               alerts=$((alerts + 1))
           fi
       done
       
       return $alerts
   }
   
   generate_cron_report() {
       local report_file="/opt/cron/logs/cron-monitor-report-$(date +%Y%m%d).txt"
       
       cat > "$report_file" << EOF
   Cron Monitoring Report
   Generated: $(date)
   
   Cron Service Status:
   $(systemctl status crond --no-pager -l)
   
   Active Cron Jobs:
   $(crontab -l 2>/dev/null | grep -v "^#" | grep -v "^$")
   
   System Cron Jobs:
   $(cat /etc/cron.d/* 2>/dev/null | grep -v "^#" | grep -v "^$")
   
   Recent Cron Activity:
   $(tail -20 /var/log/cron 2>/dev/null)
   
   Job Log Files:
   $(ls -la /opt/cron/logs/*.log 2>/dev/null)
   EOF
       
       log_message "INFO" "Cron monitoring report generated: $report_file"
   }
   
   main() {
       log_message "INFO" "Starting cron monitoring"
       
       local issues=0
       
       check_cron_service || issues=$((issues + 1))
       analyze_cron_logs
       check_job_completion || issues=$((issues + 1))
       generate_cron_report
       
       if [ $issues -gt 0 ]; then
           log_message "WARN" "Cron monitoring completed with $issues issues"
       else
           log_message "INFO" "Cron monitoring completed - all checks passed"
       fi
   }
   
   main "$@"

2. Create cron job management utility:
   # vim /opt/cron/scripts/cron-manager.sh
   
   #!/bin/bash
   #
   # Cron Job Management Utility
   #
   
   CRON_DIR="/opt/cron"
   LOG_FILE="$CRON_DIR/logs/cron-manager.log"
   
   log_message() {
       echo "$(date '+%Y-%m-%d %H:%M:%S') [$1] $2" >> "$LOG_FILE"
   }
   
   list_jobs() {
       echo "=== System Cron Jobs ==="
       cat /etc/cron.d/* 2>/dev/null | grep -v "^#" | grep -v "^$"
       echo
       
       echo "=== User Cron Jobs ==="
       crontab -l 2>/dev/null | grep -v "^#" | grep -v "^$"
       echo
       
       echo "=== Cron Scripts ==="
       ls -la "$CRON_DIR/scripts/"
   }
   
   enable_job() {
       local job_file="$1"
       
       if [ -f "/etc/cron.d/$job_file.disabled" ]; then
           mv "/etc/cron.d/$job_file.disabled" "/etc/cron.d/$job_file"
           log_message "INFO" "Enabled cron job: $job_file"
           echo "Job enabled: $job_file"
       else
           echo "Job file not found or already enabled: $job_file"
       fi
   }
   
   disable_job() {
       local job_file="$1"
       
       if [ -f "/etc/cron.d/$job_file" ]; then
           mv "/etc/cron.d/$job_file" "/etc/cron.d/$job_file.disabled"
           log_message "INFO" "Disabled cron job: $job_file"
           echo "Job disabled: $job_file"
       else
           echo "Job file not found: $job_file"
       fi
   }
   
   test_job() {
       local script_name="$1"
       local script_path="$CRON_DIR/scripts/$script_name"
       
       if [ -x "$script_path" ]; then
           echo "Testing cron job script: $script_name"
           log_message "INFO" "Testing script: $script_name"
           
           # Run script in test mode
           "$script_path" --test 2>&1 | tee -a "$LOG_FILE"
           
           local exit_code=$?
           if [ $exit_code -eq 0 ]; then
               echo "Script test passed: $script_name"
               log_message "INFO" "Script test passed: $script_name"
           else
               echo "Script test failed: $script_name (exit code: $exit_code)"
               log_message "ERROR" "Script test failed: $script_name"
           fi
       else
           echo "Script not found or not executable: $script_path"
       fi
   }
   
   show_logs() {
       local job_name="$1"
       local lines="${2:-50}"
       
       if [ -n "$job_name" ]; then
           local log_file="$CRON_DIR/logs/${job_name}.log"
           if [ -f "$log_file" ]; then
               echo "=== Last $lines lines of $job_name log ==="
               tail -n "$lines" "$log_file"
           else
               echo "Log file not found: $log_file"
           fi
       else
           echo "=== Available log files ==="
           ls -la "$CRON_DIR/logs/"*.log 2>/dev/null
       fi
   }
   
   cleanup_logs() {
       local retention_days="${1:-30}"
       
       echo "Cleaning log files older than $retention_days days"
       log_message "INFO" "Starting log cleanup (retention: $retention_days days)"
       
       local cleaned=0
       find "$CRON_DIR/logs" -name "*.log" -mtime +$retention_days -delete 2>/dev/null
       cleaned=$(find "$CRON_DIR/logs" -name "*.log" -mtime +$retention_days | wc -l)
       
       echo "Cleaned $cleaned log files"
       log_message "INFO" "Log cleanup completed: $cleaned files removed"
   }
   
   usage() {
       cat << EOF
   Usage: $0 <command> [options]
   
   Commands:
     list                    List all cron jobs
     enable <job_file>       Enable a disabled cron job
     disable <job_file>      Disable a cron job
     test <script_name>      Test a cron script
     logs [job_name] [lines] Show logs for a job
     cleanup [days]          Clean old log files
     help                    Show this help message
   
   Examples:
     $0 list
     $0 enable system-automation
     $0 test system-cleanup.sh
     $0 logs system-monitoring 100
     $0 cleanup 7
   EOF
   }
   
   main() {
       local command="$1"
       shift
       
       case "$command" in
           "list")
               list_jobs
               ;;
           "enable")
               enable_job "$1"
               ;;
           "disable")
               disable_job "$1"
               ;;
           "test")
               test_job "$1"
               ;;
           "logs")
               show_logs "$1" "$2"
               ;;
           "cleanup")
               cleanup_logs "$1"
               ;;
           "help"|"--help"|"-h")
               usage
               ;;
           *)
               echo "Unknown command: $command"
               usage
               exit 1
               ;;
       esac
   }
   
   main "$@"
PART E: ERROR HANDLING AND NOTIFICATIONS
----------------------------------------

1. Create error handling framework for cron jobs:
   # vim /opt/cron/scripts/cron-error-handler.sh
   
   #!/bin/bash
   #
   # Cron Error Handling Framework
   #
   
   ERROR_LOG="/opt/cron/logs/cron-errors.log"
   NOTIFICATION_CONFIG="/opt/cron/configs/notifications.conf"
   
   # Default notification settings
   ENABLE_EMAIL=false
   ADMIN_EMAIL="admin@example.com"
   ERROR_THRESHOLD=5
   
   # Load notification configuration
   if [ -f "$NOTIFICATION_CONFIG" ]; then
       source "$NOTIFICATION_CONFIG"
   fi
   
   log_error() {
       local job_name="$1"
       local error_message="$2"
       local severity="${3:-ERROR}"
       
       echo "$(date '+%Y-%m-%d %H:%M:%S') [$severity] [$job_name] $error_message" >> "$ERROR_LOG"
   }
   
   send_notification() {
       local subject="$1"
       local message="$2"
       local priority="${3:-normal}"
       
       if [ "$ENABLE_EMAIL" = true ] && command -v mail >/dev/null 2>&1; then
           echo "$message" | mail -s "$subject" "$ADMIN_EMAIL"
           log_error "notification" "Email sent: $subject" "INFO"
       fi
       
       # Log to system log
       logger -p local0.err "CRON-ERROR: $subject - $message"
   }
   
   check_error_threshold() {
       local job_name="$1"
       local time_window="${2:-3600}"  # 1 hour default
       
       local current_time=$(date +%s)
       local cutoff_time=$((current_time - time_window))
       local cutoff_date=$(date -d "@$cutoff_time" '+%Y-%m-%d %H:%M:%S')
       
       local error_count=$(awk -v cutoff="$cutoff_date" -v job="$job_name" '
           $0 > cutoff && $0 ~ job && /ERROR/ {count++}
           END {print count+0}
       ' "$ERROR_LOG")
       
       if [ "$error_count" -ge "$ERROR_THRESHOLD" ]; then
           send_notification "Cron Job Error Threshold Exceeded" \
               "Job $job_name has generated $error_count errors in the last hour" \
               "high"
           return 1
       fi
       
       return 0
   }
   
   handle_job_failure() {
       local job_name="$1"
       local exit_code="$2"
       local error_output="$3"
       
       log_error "$job_name" "Job failed with exit code $exit_code" "ERROR"
       
       if [ -n "$error_output" ]; then
           log_error "$job_name" "Error output: $error_output" "ERROR"
       fi
       
       # Check if we've exceeded error threshold
       if ! check_error_threshold "$job_name"; then
           log_error "$job_name" "Error threshold exceeded, notifications sent" "WARN"
       fi
       
       # Attempt recovery actions based on job type
       case "$job_name" in
           "backup-automation")
               log_error "$job_name" "Attempting backup recovery" "INFO"
               # Could implement backup recovery logic here
               ;;
           "system-monitoring")
               log_error "$job_name" "Restarting monitoring services" "INFO"
               systemctl restart crond
               ;;
       esac
   }
   
   generate_error_report() {
       local report_file="/opt/cron/logs/error-report-$(date +%Y%m%d).txt"
       local today=$(date +%Y-%m-%d)
       
       cat > "$report_file" << EOF
   Cron Error Report
   Generated: $(date)
   
   Today's Errors:
   $(grep "$today" "$ERROR_LOG" | grep "ERROR")
   
   Error Summary by Job:
   $(grep "$today" "$ERROR_LOG" | grep "ERROR" | awk '{print $4}' | sort | uniq -c | sort -nr)
   
   Recent Critical Errors:
   $(grep "$today" "$ERROR_LOG" | grep "CRITICAL" | tail -10)
   EOF
       
       echo "Error report generated: $report_file"
   }

2. Create notification system:
   # vim /opt/cron/configs/notifications.conf
   
   # Cron Job Notification Configuration
   
   # Email settings
   ENABLE_EMAIL=true
   ADMIN_EMAIL="admin@example.com"
   SMTP_SERVER="localhost"
   
   # Error thresholds
   ERROR_THRESHOLD=3
   WARNING_THRESHOLD=5
   
   # Notification frequency (minutes)
   MIN_NOTIFICATION_INTERVAL=60
   
   # Job-specific settings
   CRITICAL_JOBS="backup-automation system-monitoring"
   HIGH_PRIORITY_JOBS="system-cleanup security-updates"

3. Create cron job wrapper with error handling:
   # vim /opt/cron/scripts/cron-wrapper.sh
   
   #!/bin/bash
   #
   # Cron Job Wrapper with Error Handling
   #
   
   WRAPPER_LOG="/opt/cron/logs/cron-wrapper.log"
   ERROR_HANDLER="/opt/cron/scripts/cron-error-handler.sh"
   
   if [ $# -lt 1 ]; then
       echo "Usage: $0 <script_to_run> [arguments...]"
       exit 1
   fi
   
   SCRIPT_TO_RUN="$1"
   shift
   SCRIPT_ARGS="$@"
   SCRIPT_NAME=$(basename "$SCRIPT_TO_RUN" .sh)
   
   log_wrapper() {
       echo "$(date '+%Y-%m-%d %H:%M:%S') [WRAPPER] [$SCRIPT_NAME] $1" >> "$WRAPPER_LOG"
   }
   
   # Pre-execution checks
   if [ ! -x "$SCRIPT_TO_RUN" ]; then
       log_wrapper "ERROR: Script not found or not executable: $SCRIPT_TO_RUN"
       exit 1
   fi
   
   # Check system resources before execution
   LOAD_AVG=$(uptime | awk -F'load average:' '{print $2}' | awk -F',' '{print $1}' | tr -d ' ')
   if (( $(echo "$LOAD_AVG > 5.0" | bc -l) )); then
       log_wrapper "WARNING: High system load ($LOAD_AVG), delaying execution"
       sleep 60
   fi
   
   # Execute script with timeout and capture output
   log_wrapper "Starting execution: $SCRIPT_TO_RUN $SCRIPT_ARGS"
   
   START_TIME=$(date +%s)
   TEMP_OUTPUT=$(mktemp)
   
   # Run script with timeout (30 minutes default)
   timeout 1800 "$SCRIPT_TO_RUN" $SCRIPT_ARGS > "$TEMP_OUTPUT" 2>&1
   EXIT_CODE=$?
   
   END_TIME=$(date +%s)
   DURATION=$((END_TIME - START_TIME))
   
   # Process results
   if [ $EXIT_CODE -eq 0 ]; then
       log_wrapper "SUCCESS: Completed in ${DURATION}s"
   elif [ $EXIT_CODE -eq 124 ]; then
       log_wrapper "ERROR: Script timed out after 30 minutes"
       if [ -x "$ERROR_HANDLER" ]; then
           "$ERROR_HANDLER" handle_job_failure "$SCRIPT_NAME" "$EXIT_CODE" "Script timeout"
       fi
   else
       log_wrapper "ERROR: Script failed with exit code $EXIT_CODE"
       ERROR_OUTPUT=$(cat "$TEMP_OUTPUT")
       if [ -x "$ERROR_HANDLER" ]; then
           "$ERROR_HANDLER" handle_job_failure "$SCRIPT_NAME" "$EXIT_CODE" "$ERROR_OUTPUT"
       fi
   fi
   
   # Cleanup
   rm -f "$TEMP_OUTPUT"
   
   exit $EXIT_CODE

PART F: ADVANCED CRON FEATURES
-------------------------------

1. Create dynamic cron job generator:
   # vim /opt/cron/scripts/dynamic-cron-generator.sh
   
   #!/bin/bash
   #
   # Dynamic Cron Job Generator
   #
   
   CRON_TEMPLATE_DIR="/opt/cron/templates"
   GENERATED_CRON_DIR="/etc/cron.d"
   LOG_FILE="/opt/cron/logs/cron-generator.log"
   
   log_message() {
       echo "$(date '+%Y-%m-%d %H:%M:%S') [$1] $2" >> "$LOG_FILE"
   }
   
   generate_maintenance_schedule() {
       local server_type="$1"
       local cron_file="$GENERATED_CRON_DIR/maintenance-${server_type}"
       
       log_message "INFO" "Generating maintenance schedule for $server_type"
       
       case "$server_type" in
           "web")
               cat > "$cron_file" << EOF
   # Web Server Maintenance Schedule
   # Generated: $(date)
   
   # Log rotation - daily at 2 AM
   0 2 * * * root /usr/sbin/logrotate /etc/logrotate.d/httpd
   
   # Clear web cache - every 4 hours
   0 */4 * * * root find /var/cache/httpd -type f -mtime +1 -delete
   
   # Check SSL certificates - daily at 6 AM
   0 6 * * * root /opt/cron/scripts/check-ssl-certs.sh
   
   # Restart web services - Sunday at 3 AM
   0 3 * * 0 root systemctl restart httpd
   EOF
               ;;
           "database")
               cat > "$cron_file" << EOF
   # Database Server Maintenance Schedule
   # Generated: $(date)
   
   # Database backup - daily at 1 AM
   0 1 * * * root /opt/cron/scripts/database-backup.sh
   
   # Optimize tables - Sunday at 2 AM
   0 2 * * 0 root /opt/cron/scripts/optimize-database.sh
   
   # Check database integrity - daily at 5 AM
   0 5 * * * root /opt/cron/scripts/check-database-integrity.sh
   
   # Purge old logs - weekly on Monday at 4 AM
   0 4 * * 1 root /opt/cron/scripts/purge-database-logs.sh
   EOF
               ;;
           "file")
               cat > "$cron_file" << EOF
   # File Server Maintenance Schedule
   # Generated: $(date)
   
   # File system check - Sunday at 1 AM
   0 1 * * 0 root /opt/cron/scripts/filesystem-check.sh
   
   # Clean temporary files - daily at 3 AM
   0 3 * * * root find /srv/files/temp -type f -mtime +7 -delete
   
   # Backup file shares - daily at 2 AM
   0 2 * * * root /opt/cron/scripts/backup-file-shares.sh
   
   # Check disk quotas - daily at 8 AM
   0 8 * * * root /opt/cron/scripts/check-disk-quotas.sh
   EOF
               ;;
       esac
       
       log_message "INFO" "Maintenance schedule generated: $cron_file"
   }
   
   generate_monitoring_schedule() {
       local monitoring_level="$1"
       local cron_file="$GENERATED_CRON_DIR/monitoring-${monitoring_level}"
       
       log_message "INFO" "Generating monitoring schedule for $monitoring_level level"
       
       case "$monitoring_level" in
           "basic")
               cat > "$cron_file" << EOF
   # Basic Monitoring Schedule
   # Generated: $(date)
   
   # System health check - every 30 minutes
   */30 * * * * root /opt/cron/scripts/basic-health-check.sh
   
   # Disk space check - hourly
   0 * * * * root /opt/cron/scripts/disk-space-check.sh
   
   # Service status check - every 15 minutes
   */15 * * * * root /opt/cron/scripts/service-status-check.sh
   EOF
               ;;
           "advanced")
               cat > "$cron_file" << EOF
   # Advanced Monitoring Schedule
   # Generated: $(date)
   
   # Comprehensive system monitoring - every 10 minutes
   */10 * * * * root /opt/cron/scripts/system-monitoring.sh
   
   # Performance monitoring - every 5 minutes
   */5 * * * * root /opt/cron/scripts/performance-monitoring.sh
   
   # Security monitoring - every 15 minutes
   */15 * * * * root /opt/cron/scripts/security-monitoring.sh
   
   # Network monitoring - every 5 minutes
   */5 * * * * root /opt/cron/scripts/network-monitoring.sh
   
   # Application monitoring - every 10 minutes
   */10 * * * * root /opt/cron/scripts/application-monitoring.sh
   EOF
               ;;
       esac
       
       log_message "INFO" "Monitoring schedule generated: $cron_file"
   }
   
   main() {
       local action="$1"
       local type="$2"
       
       case "$action" in
           "maintenance")
               generate_maintenance_schedule "$type"
               ;;
           "monitoring")
               generate_monitoring_schedule "$type"
               ;;
           *)
               echo "Usage: $0 {maintenance|monitoring} <type>"
               echo "Maintenance types: web, database, file"
               echo "Monitoring types: basic, advanced"
               exit 1
               ;;
       esac
       
       # Reload cron service
       systemctl reload crond
       log_message "INFO" "Cron service reloaded"
   }
   
   main "$@"

2. Create cron job performance analyzer:
   # vim /opt/cron/scripts/cron-performance-analyzer.sh
   
   #!/bin/bash
   #
   # Cron Job Performance Analyzer
   #
   
   LOG_DIR="/opt/cron/logs"
   REPORT_FILE="/opt/cron/logs/performance-analysis-$(date +%Y%m%d).txt"
   
   analyze_job_performance() {
       local job_name="$1"
       local log_file="$LOG_DIR/${job_name}.log"
       
       if [ ! -f "$log_file" ]; then
           echo "Log file not found: $log_file"
           return 1
       fi
       
       echo "=== Performance Analysis for $job_name ===" >> "$REPORT_FILE"
       
       # Extract execution times
       local execution_times=$(grep "completed in" "$log_file" | awk '{print $(NF-1)}' | sed 's/s$//')
       
       if [ -n "$execution_times" ]; then
           local count=$(echo "$execution_times" | wc -l)
           local total=$(echo "$execution_times" | awk '{sum+=$1} END {print sum}')
           local average=$(echo "scale=2; $total / $count" | bc)
           local max=$(echo "$execution_times" | sort -n | tail -1)
           local min=$(echo "$execution_times" | sort -n | head -1)
           
           cat >> "$REPORT_FILE" << EOF
   Executions analyzed: $count
   Average execution time: ${average}s
   Minimum execution time: ${min}s
   Maximum execution time: ${max}s
   Total execution time: ${total}s

   EOF
       else
           echo "No execution time data found" >> "$REPORT_FILE"
       fi
       
       # Check for errors
       local error_count=$(grep -c "ERROR" "$log_file")
       local warning_count=$(grep -c "WARN" "$log_file")
       
       cat >> "$REPORT_FILE" << EOF
   Error count: $error_count
   Warning count: $warning_count

   EOF
   }
   
   generate_overall_report() {
       cat > "$REPORT_FILE" << EOF
   Cron Job Performance Analysis Report
   Generated: $(date)
   Analysis Period: Last 30 days
   
   EOF
       
       # Analyze each job
       for log_file in "$LOG_DIR"/*.log; do
           if [ -f "$log_file" ]; then
               local job_name=$(basename "$log_file" .log)
               analyze_job_performance "$job_name"
           fi
       done
       
       # System-wide statistics
       cat >> "$REPORT_FILE" << EOF
   === System-wide Cron Statistics ===
   
   Total cron jobs configured: $(crontab -l 2>/dev/null | grep -v "^#" | grep -v "^$" | wc -l)
   System cron jobs: $(find /etc/cron.d -name "*" -type f | wc -l)
   
   Cron service uptime: $(systemctl show crond --property=ActiveEnterTimestamp --value)
   
   Recent cron activity:
   $(tail -10 /var/log/cron)
   EOF
       
       echo "Performance analysis report generated: $REPORT_FILE"
   }
   
   main() {
       local action="${1:-report}"
       
       case "$action" in
           "analyze")
               analyze_job_performance "$2"
               ;;
           "report")
               generate_overall_report
               ;;
           *)
               echo "Usage: $0 {analyze <job_name>|report}"
               exit 1
               ;;
       esac
   }
   
   main "$@"

PART G: TESTING AND VALIDATION
-------------------------------

1. Test cron service and configuration:
   # systemctl status crond
   # crontab -l
   # cat /etc/cron.d/system-automation

2. Test cron job scripts:
   # chmod +x /opt/cron/scripts/*.sh
   # /opt/cron/scripts/system-cleanup.sh
   # /opt/cron/scripts/backup-automation.sh daily
   # /opt/cron/scripts/system-monitoring.sh

3. Test cron job wrapper:
   # /opt/cron/scripts/cron-wrapper.sh /opt/cron/scripts/system-monitoring.sh

4. Test cron monitoring:
   # /opt/cron/scripts/cron-monitor.sh
   # cat /opt/cron/logs/cron-monitor.log

5. Test cron management utility:
   # /opt/cron/scripts/cron-manager.sh list
   # /opt/cron/scripts/cron-manager.sh logs system-monitoring 20

6. Test dynamic cron generation:
   # /opt/cron/scripts/dynamic-cron-generator.sh maintenance web
   # /opt/cron/scripts/dynamic-cron-generator.sh monitoring basic

7. Test performance analysis:
   # /opt/cron/scripts/cron-performance-analyzer.sh report

8. Validate cron job execution:
   # tail -f /var/log/cron
   # tail -f /opt/cron/logs/system-monitoring.log

TROUBLESHOOTING COMMANDS:
-------------------------
# systemctl status crond
# journalctl -u crond -f
# tail -f /var/log/cron
# crontab -l
# ls -la /etc/cron.d/
# grep CRON /var/log/messages

EXPECTED RESULTS:
-----------------
- Comprehensive cron automation system operational
- System maintenance tasks automated and scheduled
- Advanced scheduling patterns implemented
- Job monitoring and error handling functional
- Performance analysis and reporting working
- Dynamic cron job generation operational
- All scripts properly logged and monitored

VALIDATION CHECKLIST:
---------------------
□ Cron service running and configured
□ System automation scripts operational
□ Advanced scheduling patterns working
□ Job monitoring system functional
□ Error handling and notifications active
□ Performance analysis generating reports
□ Dynamic job generation working
□ All cron jobs properly scheduled
□ Logging and monitoring comprehensive
□ Management utilities operational

CLEANUP:
--------
# systemctl stop crond
# rm /etc/cron.d/system-automation
# rm /etc/cron.d/maintenance-*
# rm /etc/cron.d/monitoring-*
# rm -rf /opt/cron
# crontab -r
